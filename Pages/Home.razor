@page "/"

@using System.Timers
@inject IJSRuntime JS

<PageTitle>Kol</PageTitle>

<div class="health-tracker">
    <div class="player topPlayer">
        <div class="tap-zone top @(topPlayerTopPressed ? "pressed" : null)"
             @onpointerdown="() => HandlePointerDown(true, true, true)"
             @onpointerup="() => HandlePointerUp(true, true, false)"
             @onpointerleave="() => HandlePointerLeave(true, true, false)"></div>
        <span class="health">@topPlayerHealth</span>
        @if (topPlayerHasChanged)
        {
            <span class="change-counter @(topPlayerChangeCounter > 0 ? "positive" : topPlayerChangeCounter < 0 ? "negative" : "neutral")">@(topPlayerChangeCounter > 0 ? "+" : "")@topPlayerChangeCounter</span>
        }
        <div class="tap-zone bottom @(topPlayerBottomPressed ? "pressed" : null)"
             @onpointerdown="() => HandlePointerDown(true, false, true)"
             @onpointerup="() => HandlePointerUp(true, false, false)"
             @onpointerleave="() => HandlePointerLeave(true, false, false)"></div>
    </div>
    <div class="player bottomPlayer">
        <div class="tap-zone top @(bottomPlayerTopPressed ? "pressed" : null)"
             @onpointerdown="() => HandlePointerDown(false, true, true)"
             @onpointerup="() => HandlePointerUp(false, true, false)"
             @onpointerleave="() => HandlePointerLeave(false, true, false)"></div>
        <span class="health">@bottomPlayerHealth</span>
        @if (bottomPlayerHasChanged)
        {
            <span class="change-counter @(bottomPlayerChangeCounter > 0 ? "positive" : bottomPlayerChangeCounter < 0 ? "negative" : "neutral")">@(bottomPlayerChangeCounter > 0 ? "+" : "")@bottomPlayerChangeCounter</span>
        }
        <div class="tap-zone bottom @(bottomPlayerBottomPressed ? "pressed" : null)"
             @onpointerdown="() => HandlePointerDown(false, false, true)"
             @onpointerup="() => HandlePointerUp(false, false, false)"
             @onpointerleave="() => HandlePointerLeave(false, false, false)"></div>
    </div>
</div>

<div class="reset-container">
    <button class="reset-btn" @onclick="ResetHealth" aria-label="Reset health">
        <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="1 4 1 10 7 10" />
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" />
        </svg>
    </button>
</div>

@code {
    private const int StartHealth = 20;
    private const int VibrationDuration = 30;
    private int topPlayerHealth = StartHealth;
    private int bottomPlayerHealth = StartHealth;

    private int topPlayerChangeCounter = 0;
    private int bottomPlayerChangeCounter = 0;
    private bool topPlayerHasChanged = false;
    private bool bottomPlayerHasChanged = false;
    private Timer? topPlayerChangeTimer;
    private Timer? bottomPlayerChangeTimer;

    private bool topPlayerTopPressed = false;
    private bool topPlayerBottomPressed = false;
    private bool bottomPlayerTopPressed = false;
    private bool bottomPlayerBottomPressed = false;

    private bool isLongPress = false;

    private async void HandlePointerDown(bool isTopPlayer, bool isTop, bool pressed)
    {
        SetPressed(isTopPlayer, isTop, pressed);
        isLongPress = false;
        
        // Start long press timer
        await JS.InvokeVoidAsync("startLongPress", DotNetObjectReference.Create(this), isTop);
    }

    private async void HandlePointerUp(bool isTopPlayer, bool isTop, bool pressed)
    {
        SetPressed(isTopPlayer, isTop, pressed);
        
        // Cancel long press and handle short press
        await JS.InvokeVoidAsync("cancelLongPress");
        
        if (!isLongPress)
        {
            if (isTop)
                IncreaseHealth(isTopPlayer);
            else
                DecreaseHealth(isTopPlayer);
        }
    }

    private async void HandlePointerLeave(bool isTopPlayer, bool isTop, bool pressed)
    {
        SetPressed(isTopPlayer, isTop, pressed);
        await JS.InvokeVoidAsync("cancelLongPress");
    }

    [JSInvokable]
    public void OnLongPress(bool isIncrease)
    {
        isLongPress = true;
        // Determine which player and zone based on current state
        bool isTopPlayer = topPlayerTopPressed || topPlayerBottomPressed;
        bool isTop = topPlayerTopPressed || bottomPlayerTopPressed;
        
        LongPressHealth(isTopPlayer, isIncrease);
    }

    private async void SetPressed(bool isTopPlayer, bool isTop, bool pressed)
    {
        if (isTopPlayer)
        {
            if (isTop) topPlayerTopPressed = pressed;
            else topPlayerBottomPressed = pressed;
        }
        else
        {
            if (isTop) bottomPlayerTopPressed = pressed;
            else bottomPlayerBottomPressed = pressed;
        }
        if (pressed)
        {
            await JS.InvokeVoidAsync("vibrate", VibrationDuration);
        }
    }

    private async void IncreaseHealth(bool isTopPlayer)
    {
        if (isTopPlayer)
        {
            topPlayerHealth++;
            UpdateChangeCounter(true, 1);
        }
        else
        {
            bottomPlayerHealth++;
            UpdateChangeCounter(false, 1);
        }
        
        await JS.InvokeVoidAsync("playHealthIncrease");
    }

    private async void DecreaseHealth(bool isTopPlayer)
    {
        if (isTopPlayer)
        {
            topPlayerHealth--;
            UpdateChangeCounter(true, -1);
        }
        else
        {
            bottomPlayerHealth--;
            UpdateChangeCounter(false, -1);
        }
        
        await JS.InvokeVoidAsync("playHealthDecrease");
    }

    private async void LongPressHealth(bool isTopPlayer, bool isIncrease)
    {
        int change = isIncrease ? 10 : -10;
        if (isTopPlayer)
        {
            topPlayerHealth += change;
            UpdateChangeCounter(true, change);
        }
        else
        {
            bottomPlayerHealth += change;
            UpdateChangeCounter(false, change);
        }
        
        await JS.InvokeVoidAsync(isIncrease ? "playHealthIncrease" : "playHealthDecrease");
    }

    private void UpdateChangeCounter(bool isTopPlayer, int change)
    {
        if (isTopPlayer)
        {
            topPlayerChangeCounter += change;
            topPlayerHasChanged = true;
            StartChangeTimer(true);
        }
        else
        {
            bottomPlayerChangeCounter += change;
            bottomPlayerHasChanged = true;
            StartChangeTimer(false);
        }
        StateHasChanged();
    }

    private void StartChangeTimer(bool isTopPlayer)
    {
        const int ChangeTimerDuration = 1500; // Milliseconds

        if (isTopPlayer)
        {
            topPlayerChangeTimer?.Dispose();
            topPlayerChangeTimer = new Timer(ChangeTimerDuration);
            topPlayerChangeTimer.Elapsed += (sender, e) => ResetChangeCounter(true);
            topPlayerChangeTimer.AutoReset = false;
            topPlayerChangeTimer.Start();
        }
        else
        {
            bottomPlayerChangeTimer?.Dispose();
            bottomPlayerChangeTimer = new Timer(ChangeTimerDuration);
            bottomPlayerChangeTimer.Elapsed += (sender, e) => ResetChangeCounter(false);
            bottomPlayerChangeTimer.AutoReset = false;
            bottomPlayerChangeTimer.Start();
        }
    }

    private void ResetChangeCounter(bool isTopPlayer)
    {
        if (isTopPlayer)
        {
            topPlayerChangeCounter = 0;
            topPlayerHasChanged = false;
        }
        else
        {
            bottomPlayerChangeCounter = 0;
            bottomPlayerHasChanged = false;
        }
        
        InvokeAsync(StateHasChanged);
    }

    private void ResetHealth()
    {
        topPlayerHealth = StartHealth;
        bottomPlayerHealth = StartHealth;
        
        // Reset change counters and hide them
        topPlayerChangeCounter = 0;
        bottomPlayerChangeCounter = 0;
        topPlayerHasChanged = false;
        bottomPlayerHasChanged = false;
        
        // Stop any running timers
        topPlayerChangeTimer?.Dispose();
        bottomPlayerChangeTimer?.Dispose();
    }

    public void Dispose()
    {
        topPlayerChangeTimer?.Dispose();
        bottomPlayerChangeTimer?.Dispose();
    }
}

<script>
  window.vibrate = function (duration) {
    if (navigator.vibrate) {
      navigator.vibrate(duration);
    }
  }

  // Wake lock to prevent screen dimming
  let wakeLock = null;

  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock is active');
        
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock was released');
        });
      }
    } catch (err) {
      console.error('Wake Lock error:', err);
    }
  }

  // Request wake lock when page loads
  document.addEventListener('DOMContentLoaded', requestWakeLock);

  // Force fullscreen and handle viewport
  function setupFullscreen() {
    // Set viewport height properly for mobile browsers
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
    
    // Try to enter fullscreen mode if supported
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log('Fullscreen request failed:', err);
      });
    }
    
    // Handle orientation changes
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }, 100);
    });
  }

  // Setup fullscreen on page load
  document.addEventListener('DOMContentLoaded', setupFullscreen);

  // Prevent context menu and long press selection
  document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    return false;
  });

  // Prevent long press selection on all elements
  document.addEventListener('selectstart', function(e) {
    e.preventDefault();
    return false;
  });

  // Prevent drag and drop
  document.addEventListener('dragstart', function(e) {
    e.preventDefault();
    return false;
  });

  // Re-request wake lock when page becomes visible again
  document.addEventListener('visibilitychange', async () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      await requestWakeLock();
    }
  });

  // Expose wake lock functions globally
  window.requestWakeLock = requestWakeLock;

  // Sound effects using Web Audio API
  let audioContext = null;

  function initAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function playTone(frequency, duration, type = 'sine') {
    initAudio();
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  }

  function playHealthIncrease() {
    playTone(1600, 0.15, 'sine');
  }

  function playHealthDecrease() {
    playTone(800, 0.15, 'sine');
  }

  // Expose sound functions globally
  window.playHealthIncrease = playHealthIncrease;
  window.playHealthDecrease = playHealthDecrease;

  // Long press detection
  let longPressTimer = null;
  let longPressDelay = 500; // 500ms for long press

  function startLongPress(dotNetRef, isIncrease) {
    longPressTimer = setTimeout(() => {
      dotNetRef.invokeMethodAsync('OnLongPress', isIncrease);
    }, longPressDelay);
  }

  function cancelLongPress() {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  }

  // Expose long press functions globally
  window.startLongPress = startLongPress;
  window.cancelLongPress = cancelLongPress;

  // PWA Install prompt handling
  let deferredPrompt;

  window.addEventListener('beforeinstallprompt', (e) => {
    // Prevent Chrome 67 and earlier from automatically showing the prompt
    e.preventDefault();
    // Stash the event so it can be triggered later
    deferredPrompt = e;
    console.log('Install prompt ready');
    
    // Optionally show a custom install button or notification
    // You could add a button to your UI here to trigger the install
  });

  window.addEventListener('appinstalled', (evt) => {
    console.log('App was installed');
    deferredPrompt = null;
  });

  // Function to trigger install prompt (can be called from UI)
  window.triggerInstall = function() {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then((choiceResult) => {
        if (choiceResult.outcome === 'accepted') {
          console.log('User accepted the install prompt');
        } else {
          console.log('User dismissed the install prompt');
        }
        deferredPrompt = null;
      });
    }
  };
</script>
